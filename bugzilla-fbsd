#!/usr/bin/env python

import subprocess
import sys
import requests
from subprocess import check_call, check_output
import argparse
import re
import os


BUGZILLA_CMD=["/usr/local/bin/bugzilla", "--bugzilla", "https://bugs.freebsd.org/bugzilla/xmlrpc.cgi" ]
# XXX: What is up with --nosslverify?
BUGZILLA_CMD.append("--nosslverify")

"""
/usr/local/bin/bugzilla --bugzilla \
	  https://bugs.freebsd.org/bugzilla/xmlrpc.cgi --nosslverify attach \
	    --file "$PORTFILE" --desc "a fix" "$BUG_ID"



"""

import tempfile
import shutil
def unload_shar_from_patchfile(patchfilenam, portpath, bugid, patch_strip_count):

    (portdir, portname) = portpath.split('/')
    tmpdir = None

    if patch_strip_count is None:
	"""
	Do a quick heuristic to determine if we're a git patchfile and if
	so if we have the leading a/b parts we need to strip off by passing
	-p1 to patch(1)
	"""
	has_git_diff = False
	has_git_leading_ab = False
	pfile = open(patchfilenam, "r")
	for line in pfile:
	    if re.match("^diff --git ", line):
		has_git_diff = True
	    if re.match("^+++ b/", line):
		has_git_leading_ab = False
	if has_git_diff and has_git_leading_ab:
	    patch_strip_count = 1
	else:
	    patch_strip_count = 0
    
    try:
	tmpdir = tempfile.mkdtemp()
	portsdir = tmpdir + '/ports'
	os.mkdir(portsdir)
	args = [ "patch", "-d", portsdir, "-p%d" % patch_strip_count, "-i", patchnam ]
	check_call(args)
	#shar `find oneko` > oneko.shar
	sharoutput = tmpdir + '/' + portname + '.shar'
	cmd = "cd '%s' && shar `find '%s'` > '%s'" % (
	    portsdir + '/' + portdir,
	    portname,
	    sharoutput)
	print "Executing: %s" % (cmd)
	check_call(cmd, shell=True)
	print sharoutput
	ADD_FILE_OPTS = [
		"attach",
		"--file", sharoutput,
		"--desc", os.path.basename(sharoutput),
		bugid,
		]
	check_call(BUGZILLA_CMD + ADD_FILE_OPTS)
    finally:
	if tmpdir is not None:
	    shutil.rmtree(tmpdir)

def upload_shar_from_fabid(fabid, portpath, bugid):
    patchnam = None
    r = requests.get('https://reviews.freebsd.org/' + fabid + '?download=true')
    (patchfd, patchnam) = tempfile.mkstemp()
    try:
	#patchnam = patchfd.name
	patchfilehandle = open(patchnam, "w")
	patchfilehandle.write(r.text)
	patchfilehandle.flush()

	unload_shar_from_patchfile(patchfilename = patchnam,  portpath=portpath, bugid=bugid)

    finally:
	if patchnam is not None:
	    os.remove(patchnam)

"""
Do sanity checking on a fabricator id, including an http request to see if it exists.
"""
def check_fabid(fabid):
    # match is start of string...
    if not re.match("^D[0-9]+$", fabid):
	print "option --fabid %s doesn't match expected regex /^D[0-9]+/"
	sys.exit(1)

    faburl = "https://reviews.freebsd.org/" + fabid
    print "Making sure fabric request exists..."
    r = requests.get(faburl)
    if r.status_code != 200:
	print "Got non 200 status code from %s: code: %d" % (faburl, r.status_code)
	sys.exit(1)

"""
Create a new bugzilla for a port based on either a patchfile or a phabric id.
"""
def new_port():
    parser = argparse.ArgumentParser(description='Upload a new port based on fabricator diff or patchfile.')
    parser.add_argument('--name', required=True, help='name of port')
    parser.add_argument('--patch-strip-count', default=None, help='Strip this many components off when peeling apart patch.  git users should use 1')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--fabid', default=None, help='fabricator id')
    group.add_argument('--patchfile', default=None, help='path to patchfile')
    args = parser.parse_args()

    if args.fabid is None and args.patchfile is None:
	print "You must give either --fabid or --patchfile argument"
	sys.exit(1)
    elif args.fabid is not None and args.patchfile is not None:
	print "You can't give both --fabid and --patchfile argument"
	sys.exit(1)

    if args.fabid:
	fabid = args.fabid
	check_fabid(fabid)

    NEW_PORT_OPTS = ["new", "-p", "Ports Tree", "-v", "Latest", "-c", "Individual Port(s)" ] 
    ADD_OPTS= [
	    "-s", "new port: %s" % args.name,
	    "-l", "new port for %s is available in phabricator at %s" % (args.name, faburl),
	    "--url", faburl,
	    "--oneline",
	    ]
    # --online <- gives back bugid for further processing...
    print BUGZILLA_CMD + ADD_OPTS
    output = check_output(BUGZILLA_CMD + NEW_PORT_OPTS + ADD_OPTS)
    bugid = output.split()[0]
    if fabid:
	upload_shar_from_fabid(fabid = args.fabid, portpath = args.name, bugid = bugid)
    else:
	unload_shar_from_patchfile(patchfilename = args.patchfile, portpath = args.name, bugid = bugid, patch_strip_count = args.patch_strip_count)

    print "New bug created at: https://bugs.freebsd.org/%d" % (bugid)

PROGNAME="bugzilla-fbsd"
if len(sys.argv) < 2:
    print "Usage: " + PROGNAME + " <login|newport> [options...]"
    sys.exit(1)

op = sys.argv.pop(1)

if op == "login":
    check_call(BUGZILLA_CMD + [ "login" ])
elif op == "newport":
    new_port()
else:
    print "unrecognized verb: '%s', options are: login, newport" % (op)
